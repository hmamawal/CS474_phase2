@book{sipser_introduction_2013,
	address = {Australia Brazil Japan Korea Mexiko Singapore Spain United Kingdom United States},
	edition = {Third edition, international edition},
	title = {Introduction to the theory of computation},
	isbn = {978-1-133-18779-0 978-1-133-18781-3 978-0-357-67058-3},
	language = {en},
	publisher = {Cengage Learning},
	author = {Sipser, Michael},
	year = {2013},
	file = {PDF:files/4/Sipser - 2013 - Introduction to the theory of computation.pdf:application/pdf},
}
@article{article,
author = {Ramos, Marcus and Almeida, José and Moreira, Nelma and Queiroz, Ruy},
year = {2019},
month = {08},
pages = {151-167},
title = {Some Applications of the Formalization of the Pumping Lemma for Context-Free Languages},
volume = {344},
journal = {Electronic Notes in Theoretical Computer Science},
doi = {10.1016/j.entcs.2019.07.010}
}

@misc{rob_useless_nodate,
	title = {Useless variables in context-free grammars},
	url = {http://kilby.stanford.edu/~rvg/154/handouts/useless.html},
	urldate = {2025-04-10},
	journal = {Useless variables in context-free grammars},
	author = {Rob, Gkabbeek},
	file = {kilby.stanford.edu/~rvg/154/handouts/useless.html#\:~\:text=A variable X in a,a word from that grammar.:files/38/useless.html:text/html},
}

@misc{colbourn_counting_2018,
	title = {Counting {Subwords} and {Regular} {Languages}},
	url = {http://arxiv.org/abs/1804.11175},
	doi = {10.48550/arXiv.1804.11175},
	abstract = {Let \$x\$ and \$y\$ be words. We consider the languages whose words \$z\$ are those for which the numbers of occurrences of \$x\$ and \$y\$, as subwords of \$z\$, are the same (resp., the number of \$x\$'s is less than the number of \$y\$'s, resp., is less than or equal). We give a necessary and sufficient condition on \$x\$ and \$y\$ for these languages to be regular, and we show how to check this condition efficiently.},
	urldate = {2025-04-10},
	publisher = {arXiv},
	author = {Colbourn, Charles J. and Dougherty, Ryan E. and Lidbetter, Thomas F. and Shallit, Jeffrey},
	month = jun,
	year = {2018},
	note = {arXiv:1804.11175 [cs]},
	keywords = {Computer Science - Formal Languages and Automata Theory},
	file = {Full Text PDF:files/36/Colbourn et al. - 2018 - Counting Subwords and Regular Languages.pdf:application/pdf;Snapshot:files/35/1804.html:text/html},
}


@misc{ramos_formalization_2015,
	title = {Formalization of simplification for context-free grammars},
	url = {https://ar5iv.labs.arxiv.org/html/1509.02032},
	abstract = {Context-free grammar simplification is a subject of high importance in computer language processing technology as well as in formal language theory. This paper presents a formalization, using the Coq proof assistant, o…},
	language = {en},
	urldate = {2025-02-25},
	journal = {ar5iv},
	author = {Ramos, Marcus and Ruy, de Queiroz},
	year = {2015},
	file = {Snapshot:files/12/1509.html:text/html},
}

@article{FARO202288,
title = {A weak approach to suffix automata simulation for exact and approximate string matching},
journal = {Theoretical Computer Science},
volume = {933},
pages = {88-103},
year = {2022},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2022.08.028},
url = {https://www.sciencedirect.com/science/article/pii/S0304397522005138},
author = {Simone Faro and Stefano Scafiti},
keywords = {Exact string matching, Swap matching, Text processing, Automata, Experimental algorithms, Design and analysis of algorithms},
abstract = {String matching is one of the most extensively studied problems in computer science, mainly due to its direct applications to such diverse areas as text, image and signal processing, speech analysis and recognition, information retrieval, data compression, computational biology and chemistry. In the last few decades a myriad of alternative solutions have been proposed, based on very different techniques. However, automata have always played a very important role in the design of efficient string matching algorithms. In this paper we present the Range Automaton, a weak yet efficient variant of the non-deterministic suffix automaton of a string whose configuration can be encoded in a very simple form and which is particularly suitable to be used for solving a multitude of text-searching problems. We will firstly develop our approach in the case of exact string matching and present an efficient algorithm, named Backward Range Automaton Matcher, which turns out to be very fast in many practical cases. Later, we will show how the Range Automaton can be adapted in an effective way also to non-standard string matching problems such as swap matching and multiple string matching. Experimental results suggest that our approach is flexible and effective for all three search problems addressed, especially in the case of long patterns.}
}
@article{kamalpreet_algorithm_2019,
	title = {Algorithm {Design} and {String} {Recognition} for {Suffix} {Strings} {Using} {Deterministic} {Finite} {Automata}.},
	volume = {8},
	issn = {22790543},
	abstract = {Theory of computation is one of the challenging and important area in field of Computer Science. The subject of automata Theory deals with variety of formal languages like Regular Languages, Context-free languages, Context-sensitive languages etc. Different formal languages have different accepting machines. For example, regular languages can be accepted by finite automata. An automaton can be used to process strings of given language. A finite automaton can be deterministic or non-deterministic in nature. Very few researchers have focused on algorithmic approach for design and implementation of Deterministic Finite Automata (DFA). Present paper aims at proposing and implementing an algorithm for DFA construction using an approach in which array of size corresponding to the states of DFA is used to store the remaining input required to complete the suffix. Algorithm to find out DFA ending with suffix will take the suffix as input from user along with the possible input characters. In the scope of present paper only regular languages based on suffix strings are considered. This algorithm will have a transition table as output. At the end, a string will be taken as input to check whether the DFA accepts it or rejects it.},
	language = {en},
	number = {2},
	journal = {IJSRR},
	author = {Kamalpreet, Singh and Gulshan, Goyal},
	year = {2019},
	pages = {8},
	file = {PDF:files/6/[No title found].pdf:application/pdf},
}
@article{ejendibia_string_2015,
	title = {String {Searching} with {DFA}-based {Algorithm}},
	volume = {9},
	issn = {22490868},
	url = {http://www.ijais.org/research/volume9/number8/ejendibia-2015-ijais-451415.pdf},
	doi = {10.5120/ijais2015451415},
	abstract = {Searching for information in large depositories or the Internet employs the concept of string searching. With the world-wide web expanding with databases from diverse fields it has become a growing concern for database curators to find an efficient searching algorithms for the task. In comparative terms, the power of an algorithm over another is in its timecomplexity and efficiency of operation. A lot of algorithms have been designed for the task of string searching. Also, some of the fast string searching algorithms were developed based on the Deterministic Finite Automata (DFA), which prompts the need to thoroughly research and investigate how this principle is applied. This paper analyses and compares the searching power of DFA and brute-force searching algorithms. The DFA approach is used to overcome the problem of backtracking, which is faced with the brute-force approach thereby improving the time complexity, the speed and efficiency of search based on results obtained.},
	language = {en},
	number = {8},
	urldate = {2025-02-19},
	journal = {IJAIS},
	author = {Ejendibia, Preye and B., Barileé},
	month = oct,
	year = {2015},
	pages = {1--6},
	file = {PDF:files/9/Ejendibia and B. - 2015 - String Searching with DFA-based Algorithm.pdf:application/pdf},
}
